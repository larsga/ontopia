<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1//EN" '' -->
<!-- "/usr/share/sgml/docbook/dtd/xml/4.1/docbookx.dtd" -->
<article> 
<title>The Built-in tolog Predicates</title>
<subtitle>Reference Documentation</subtitle>

<articleinfo>
  <author>
    <affiliation><orgname>Ontopia</orgname></affiliation>
  </author>
  <pubdate>2010-06-09</pubdate>
  <releaseinfo>5.1</releaseinfo>
</articleinfo>


<!-- ===== INTRODUCTION ====================================================-->
<section> 
<title>Introduction</title> 
<para>
The tolog query language has a number of predefined predicates which
are part of the language itself. Some of these exist in order to allow
access to various parts of the Topic Maps model, while others exist
because they provide generally useful query functionality. This
document provides a reference to all predicates that are part of the
language.
</para>

<para>
This document is quite difficult to read without a thorough
understanding of the Topic Maps model. It is recommended to study the
<ulink url="http://www.isotopicmaps.org/sam/sam-model/">Topic Maps
Data Model</ulink>.
</para>
</section>
  

<!-- ===== GENERAL =========================================================-->
<section> 
<title>The general predicates</title>

<para>
These are predicates that are built directly into the language without
being part of any specific module.
</para>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-not-equal">
<refnamediv>
<refname>/=</refname>
<refpurpose>
Compares two values to ensure they are different.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>v1</entry>
<entry>object</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The first value to compare.</entry>
</row>
<row>
<entry>v2</entry>
<entry>object</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The second value to compare.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the two values are different. For strings
this means the values must be different when compared character by
character case-sensitively, including all whitespace and special
characters. For topic map objects this means they must be different
objects. Null is different from everything except itself.
</para>

<para>
Note that this predicate <emphasis>cannot</emphasis> produce new rows
in the query or new values in any columns; it can only remove rows.
</para>

<example>
<title>Find all association types with more than two roles</title>
<literallayout>select $TYPE from
  association-role($ASSOC, $ROLE1),
  association-role($ASSOC, $ROLE2), $ROLE1 /= $ROLE2,
  association-role($ASSOC, $ROLE3), $ROLE3 /= $ROLE1, $ROLE3 /= $ROLE2
  type($ASSOC, $TYPE)?
</literallayout>
</example>

<para>
This query will first find all association roles and their
associations, then repeat each row once for each role in the same
association, and finaly remove the rowws where the two roles are the
same. The rest of the query is similar, except that the final
predicate finds the type of the association.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-equal">
<refnamediv>
<refname>=</refname>
<refpurpose>
Compares two values to ensure they are equal.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>v1</entry>
<entry>object</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The first value to compare.</entry>
</row>
<row>
<entry>v2</entry>
<entry>object</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The second value to compare.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the two values are equal using the same
comparison rule as <xref linkend="p-not-equal"/>. Note that at least
one of the values must be present. (That is, it cannot compare two
unbound variables.)
</para>

<para>
Note that unlike <xref linkend="p-not-equal"/> this predicate
<emphasis>can</emphasis> produce new values in columns.
</para>

<example>
<title>Find all operas premiered on a given date</title>
<literallayout>premiere-date($OPERA, $DATE),
$DATE = "1870 (22 Feb)"?</literallayout>
</example>

<para>
This query will first set <symbol>$DATE</symbol> to the given date,
then find all operas premiered on that date. (Thanks to the query
optimizer; if that is turned off the query will be rather less
efficient, if not really slow.)
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-less-than">
<refnamediv>
<refname>&lt;</refname>
<refpurpose>
Compares two values to ensure the first is less than the second.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>v1</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The first value to compare.</entry>
</row>
<row>
<entry>v2</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The second value to compare.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the first value is less than the second.
Note that this predicate will never bind any values, nor produce any
new result rows. Like <xref linkend="p-not-equal"/> it can only filter
out matches.
</para>

<example>
<title>Find all operas premiered before 1900</title>
<literallayout>premiere-date($OPERA, $DATE),
$DATE &lt; "1900"?</literallayout>
</example>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-less-than-equal">
<refnamediv>
<refname>&lt;=</refname>
<refpurpose>
Compares two values to ensure the first is less than or equal to the
second.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>v1</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The first value to compare.</entry>
</row>
<row>
<entry>v2</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The second value to compare.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the first value is less than or equal to
the second.  Note that this predicate will never bind any values, nor
produce any new result rows. Like <xref linkend="p-not-equal"/> it can
only filter out matches.
</para>

<example>
<title>Find all operas premiered before 1900</title>
<literallayout>premiere-date($OPERA, $DATE),
$DATE &lt;= "1900"?</literallayout>
</example>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-greater-than">
<refnamediv>
<refname>&gt;</refname>
<refpurpose>
Compares two values to ensure the first is greater than the second.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>v1</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The first value to compare.</entry>
</row>
<row>
<entry>v2</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The second value to compare.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the first value is greater than the second.
Note that this predicate will never bind any values, nor produce any
new result rows. Like <xref linkend="p-not-equal"/> it can only filter
out matches.
</para>

<example>
<title>Find all operas premiered after 1900</title>
<literallayout>premiere-date($OPERA, $DATE),
$DATE &gt; "1900"?</literallayout>
</example>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-greater-than-equal">
<refnamediv>
<refname>&gt;=</refname>
<refpurpose>
Compares two values to ensure the first is greater than or equal to
the second.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>v1</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The first value to compare.</entry>
</row>
<row>
<entry>v2</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The second value to compare.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the first value is greater than or equal to
the second. Note that this predicate will never bind any values, nor
produce any new result rows. Like <xref linkend="p-not-equal"/> it can
only filter out matches.
</para>

<example>
<title>Find all operas premiered after 1900</title>
<literallayout>premiere-date($OPERA, $DATE),
$DATE &gt;= "1900"?</literallayout>
</example>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-coalesce">
<refnamediv>
<refname>coalesce</refname>
<refpurpose>
 This predicate is often used to assign fallback or default values to
 variables. If the first argument is unbound then it is bound to the
 first non-null argument following it. If the first argument is bound
 then it will be compared to the first non-null argument following it.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>result</entry>
<entry>object</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The result value.</entry>
</row>
<row>
<entry>v1..vN</entry>
<entry>object+</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The value to check to see if it is not null. If not null then it will be bound or compared to the result argument. In that case any following arguments will be ignored.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The coalesce predicate is often used to assign default values, and is
quite often used with optional clauses as can be seen in the example
below:
</para>

<example>
<title>Find all operas and their illustrations. Assign a default illustration to the operas that do not have one already.</title>
<literallayout>select $OPERA, $ILLUSTRATION from 
instance-of($OPERA, opera), { illustration($OPERA, $I) }, 
coalesce($ILLUSTRATION, $I, "http://example.org/nicephoto.jpg")?</literallayout>
</example>
</refsect1>
</refentry>

</section>

<!-- ===== TOPIC MAPS =======================================================-->
<section>
<title>The Topic Maps predicates</title>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-association">
<refnamediv>
<refname>association</refname>
<refpurpose>
Used to verify that a value is actually an association.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>assoc</entry>
<entry>association</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The value being tested.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
This predicate is true if the parameter is an association, and false
if it is not. If used with an unbound variable it will produce all
associations in the topic map.
</para>

<example>
<title>Counting the associations in the topic map</title>
<literallayout>select count($ASSOC) from
  association($ASSOC)?
</literallayout>
</example>

<para>
The above query counts the associations in the topic map by first
producing all of them, then counting them.
</para>

<example>
<title>Finding all association types</title>
<literallayout>select $TYPE from
  association($ASSOC), type($ASSOC, $TYPE)?
</literallayout>
</example>

<para>
The above query first finds all associations in the topic map, then
finds the type of each, and finally reduces the result to only the
types.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-association-role">
<refnamediv>
<refname>association-role</refname>
<refpurpose>
Used to query the relationship between associations and the roles they
contain.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>assoc</entry>
<entry>association</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The association containing the roles.</entry>
</row>
<row>
<entry>role</entry>
<entry>association role</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The association role contained in the association.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
This predicate is true for a given association and association role if
the association role is contained in the role. Can be used to find the
association a role belongs to, all roles in an association, or all
roles in all associations. 
</para>

<example>
<title>Finding all unary association types</title>
<literallayout>select $TYPE from
  association-role($ASSOC, $ROLE1),
  not(association-role($ASSOC, $ROLE2), $ROLE2 /= $ROLE1),
  type($ASSOC, $TYPE)?
</literallayout>
</example>

<para>
The above query first finds all roles in all associations, then
removes the associations where there exists another role in the same
association, finds the type of the association, and projects us down
to the list of types. (So for any given type in the result there
<emphasis>could</emphasis> be associations that are instances of it
which are not unary. This can be solved, but is more involved.)
</para>

<example>
<title>Finding all associations between two topics</title>
<literallayout>select $ASSOC from
  role-player($ROLE1, topic1),
  association-role($ASSOC, $ROLE1),
  association-role($ASSOC, $ROLE2),
  role-player($ROLE2, topic2)?
</literallayout>
</example>

<para>
The above query first finds all roles played by
<symbol>topic1</symbol>, then finds the association of the role, then
finds all other roles in the same association, then removes all rows
where the second role isn't played by <symbol>topic2</symbol>, and
finally projects us down to just the associations.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-base-locator">
<refnamediv>
<refname>base-locator</refname>
<refpurpose>
Used to find the base locator of the topic map.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>locator</entry>
<entry>locator</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The base locator of the topic map.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
This predicate is true for a single value: the base locator of the
topic map, if it has one.
</para>

<example>
<title>Finding the base locator of the topic map</title>
<literallayout>base-locator($LOC)?
</literallayout>
</example>

<para>
This will return the base locator of the topic map, if it has one.
For a topic map loaded from a file this will be the URI of the file,
while for an RDBMS topic map this will a JDBC URI pointing to the
database.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-direct-instance-of">
<refnamediv>
<refname>direct-instance-of</refname>
<refpurpose>
Used to query the types topic are instances of; usually to find the
most specific types of the topics.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>instance</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The instance topic.</entry>
</row>
<row>
<entry>type</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The type topic.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
This predicate is true when the <symbol>instance</symbol> topic is
explicitly defined by the topic map as being an instance of the
<symbol>type</symbol> topic. (Contrast with <xref
linkend="p-instance-of"/>, where this need not be said explicitly.)
</para>

<example>
<title>Finding all topic types in the topic map</title>
<literallayout>select $TYPE from
  direct-instance-of($INSTANCE, $TYPE)?
</literallayout>
</example>

<para>
This will find all instance-type pairs in the topic map, then cut away
the instances, leaving only the types.
</para>

<example>
<title>Finding persons and their types</title>
<literallayout>
  instance-of($PERSON, person),
  direct-instance-of($PERSON, $TYPE)?
</literallayout>
</example>

<para>
In the <filename>opera.ltm</filename> topic map this query would
first find all instances of the type <symbol>person</symbol> (that is,
the instances of all subtypes of person, such as composers,
librettists, writers, characters, and so on), and then find the types
actually given to the topics in the topic map. The result would be
something like the table shown below.</para>

<table>
<title>Example query result</title>
<tgroup cols="2">
<thead>
<row>
  <entry>PERSON</entry>
  <entry>TYPE</entry>
</row>
</thead>
<tbody>
<row>
  <entry>Ulrica</entry>
  <entry>Character</entry>
</row>
<row>
  <entry>La Rocca</entry>
  <entry>Character</entry>
</row>
<row>
  <entry>Maddalena</entry>
  <entry>Character</entry>
</row>
<row>
  <entry>...</entry>
  <entry>...</entry>
</row>
<row>
  <entry>Cammarano, Salvatore</entry>
  <entry>Librettist</entry>
</row>
<row>
  <entry>Civinini, Guelfo</entry>
  <entry>Librettist</entry>
</row>
<row>
  <entry>Daudet, Alphonse</entry>
  <entry>Writer</entry>
</row>
<row>
  <entry>...</entry>
  <entry>...</entry>
</row>
</tbody>
</tgroup>
</table>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-instance-of">
<refnamediv>
<refname>instance-of</refname>
<refpurpose>
Used to query the types topic are instances of; takes the
superclass-subclass association into account.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>instance</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The instance topic.</entry>
</row>
<row>
<entry>type</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The type topic.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
This predicate is true when the <symbol>instance</symbol> topic is an
instance of the <symbol>type</symbol> topic. This can be either
directly, or <symbol>instance</symbol> can be an instance of a type
that is a subtype of <symbol>type</symbol>. Note that for this to work
the superclass-subclass association type must use the XTM 1.0 PSIs.
(Contrast with <xref linkend="p-direct-instance-of"/>, where this
needs to be said explicitly in the topic map, and the
superclass-subclass associations are ignored.)
</para>

<example>
<title>Finding all abstract topic types in the topic map</title>
<literallayout>select $TYPE from
  instance-of($INST, $TYPE),
  not(direct-instance-of($INST, $TYPE))?
</literallayout>
</example>

<para>
This will find all type-instance pairs, but then remove pairs where it
is explicitly said in the topic map that <varname>$INST</varname> is
an instance of <varname>$TYPE</varname>. This will leave us with only
the types which have no direct instances, that is, where all instances
are instances of one of the subtypes. Such types are often called
abstract types. One example of this in the Italian Opera topic map is
"place". There are lots of places, such as cities, regions, and
countries, but they are always defined as instances of one of the more
specific types, never as just "place".
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-object-id">
<refnamediv>
<refname>object-id</refname>
<refpurpose>
Used to query object IDs of topic map objects.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>object</entry>
<entry>topic map, topic, topic name, variant, occurrence, association,
       association role</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The topic map object that has the ID.</entry>
</row>
<row>
<entry>id</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The object ID of the topic map object.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
This predicate is true when the <symbol>id</symbol> is the object ID
of the <symbol>object</symbol>. It can be used to find the object ID
of a specific object, to find the object that has a specific ID, or to
find all object IDs in the topic map.
</para>

<para>
Note that the object ID is <emphasis>not</emphasis> the same as the
symbolic ID used in XTM or LTM files; for this, see the <xref
linkend="p-item-identifier"/> predicate.
</para>

<example>
<title>Finding the object ID of Puccini</title>
<literallayout>object-id(puccini, $ID)?</literallayout>
</example>

<para>
This query will produce the object ID after having looked up the
Puccini topic. Note that the ID will <emphasis>not</emphasis> be
<literal>"puccini"</literal>, but rather something like
<literal>"2532"</literal>.
</para>

<example>
<title>Finding the object with ID 241</title>
<literallayout>object-id($OBJECT, "241")?
</literallayout>
</example>

<para>
What this will return for any given topic map can't be predicted (try
it in the Omnigator!), but in any non-trivial topic map it will find
<emphasis>something</emphasis>.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-occurrence">
<refnamediv>
<refname>occurrence</refname>
<refpurpose>
Used to query the topic-occurrence relationship.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>topic</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The topic that has the occurrence.</entry>
</row>
<row>
<entry>occurrence</entry>
<entry>occurrence</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The occurrence of the topic.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
This predicate is true when the <symbol>occurrence</symbol> is an
occurrence of the <symbol>topic</symbol>. This is useful for finding
the topic an occurrence belongs to, or all occurrences of a topic, or
just all occurrences in the topic map.
</para>

<example>
<title>Finding all occurrences of a topic</title>
<literallayout>select $TYPE, $VALUE from
  occurrence(topic, $OCC),
  type($OCC, $TYPE),
  { resource($OCC, $VALUE) | value($OCC, $VALUE) }?
</literallayout>
</example>

<para>
This query will first find all occurrences of the topic, then the type
of the occurrence, then either the URI of the occurrence or its string
value, and finally make a (type, value) table of the results.
</para>

<example>
<title>Finding all persons born on a specific date</title>
<literallayout>select $PERSON from
  occurrence($PERSON, $OCC),
  type($OCC, date-of-birth),
  value($OCC, "1973-12-25")?
</literallayout>
</example>

<para>
This query will first find all occurrences of all topics, then remove
the occurrences that are not <symbol>date-of-birth</symbol>
occurrences, and then remove all occurrences that don't have
<literal>"1973-12-25"</literal> as their value, and finally we project
down to only the topics that have these occurrences. 
</para>

<para>
Note that the easiest way to do this is to use a dynamic occurrence
predicate:
</para>

<example>
<title>Finding all persons born on a specific date</title>
<literallayout>date-of-birth($PERSON, "1973-12-25")?</literallayout>
</example>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-reifies">
<refnamediv>
<refname>reifies</refname>
<refpurpose>
Used to query the relationship between a reifying topic and the thing
it reifies.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>reifier</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The reifying topic.</entry>
</row>
<row>
<entry>reified</entry>
<entry>topic map, association, association role, topic name, variant, or
       occurrence</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The reified topic map construct.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
This predicate is true when the <symbol>reifier</symbol> is an
topic that reifies the <symbol>reified</symbol>. This is useful when
you use reification and want to navigate from the name, occurrence, or
association to the reifying topic (or vice versa).
</para>

<example>
<title>Finding the topic reifying the topic map</title>
<literallayout>select $TOPIC from
  topicmap($TM), reifies($TOPIC, $TM)?
</literallayout>
</example>

<para>
This query finds the topic map first, then the topic reifying it (if
there is one).
</para>

<example>
<title>Redefining the <symbol>reifies</symbol> predicate</title>
<literallayout>reifies($T, $O) :-
  subject-identifier($T, $LOC),
  item-identifier($O, $LOC).</literallayout>
</example>

<para>
If tolog did not have the <symbol>reifies</symbol> predicate, the rule
above could have been used to free it.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-resource">
<refnamediv>
<refname>resource</refname>
<refpurpose>
Used to find the URI of an occurrence or variant name, or to find the
occurrences and variant names that have a particular URI.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>object</entry>
<entry>occurrence, variant</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The occurrence or variant which has the URI.</entry>
</row>
<row>
<entry>locator</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The URI of the occurrence or variant.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the occurrence or variant has the
<symbol>locator</symbol> as its URI value. This is useful for looking
up all occurrences/variants with a specific URI, or finding the URI of
a variant/occurrence, or all occurrences/variants which have URI
values.
</para>

<example>
<title>Find Ontopia's home page</title>
<literallayout>select $URI from
  occurrence(ontopia, $OCC),
  type($OCC, homepage),
  resource($OCC, $URI)?
</literallayout>
</example>

<para>
This query will find all occurrences of the topic
<symbol>ontopia</symbol>, then remove the ones that are not homepage
occurrences, and finally find the URIs of the ones remaining.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-role-player">
<refnamediv>
<refname>role-player</refname>
<refpurpose>
Used to find the topic playing a specific role, or all the roles
played by a topic.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>role</entry>
<entry>association role</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The role played by the topic.</entry>
</row>
<row>
<entry>topic</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The topic playing the role.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>topic</symbol> plays the given
<symbol>role</symbol>. This is useful for finding all roles played by
a topic, or the topic playing a particular role.
</para>

<example>
<title>Finding all associations between two topics</title>
<literallayout>select $ASSOC from
  role-player($ROLE1, topic1),
  association-role($ASSOC, $ROLE1),
  association-role($ASSOC, $ROLE2),
  role-player($ROLE2, topic2)?
</literallayout>
</example>

<para>
The above query first finds all roles played by
<symbol>topic1</symbol>, then finds the association of the role, then
finds all other roles in the same association, then removes all rows
where the second role isn't played by <symbol>topic2</symbol>, and
finally projects us down to just the associations.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-scope">
<refnamediv>
<refname>scope</refname>
<refpurpose>
Used to query the scopes of topic characteristics.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>scoped</entry>
<entry>topic name, variant, occurrence, association</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The thing having the scope.</entry>
</row>
<row>
<entry>theme</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The scoping topic.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>theme</symbol> is a topic in
the scope of the <symbol>scoped</symbol> thing. This is useful for
finding topic characteristics in a particular scope, finding the scope
of a topic characteristic, and so on.
</para>

<example>
<title>Finding the English names of all operas</title>
<literallayout>select $NAME from
  instance-of($OPERA, opera),
  topic-name($OPERA, $TNAME),
  scope($TNAME, english),
  value($TNAME, $NAME)?
</literallayout>
</example>

<para>
The above query first finds all operas, then all topic names (or base
names) of the operas, then removes the names that are not in the
English scope, and finally finds the string value of the remaining
names.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-item-identifier">
<refnamediv>
<refname>item-identifier</refname>
<refpurpose>
Used to query the item identifiers of a topic map construct.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>object</entry>
<entry>topic map, topic, topic name, variant, occurrence, association,
association role</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The object having the item identifier.</entry>
</row>
<row>
<entry>locator</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The item identifier of the object.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para> The predicate is true when the <symbol>locator</symbol> is a
item identifier for the <symbol>object</symbol>. This is useful for
finding the item identifiers of a particular object, for looking up
the object that has a particular item identifier, or for listing all
item identifiers in the topic map.  </para>

<example>
<title>Find all non-topics which have item identifiers</title>
<literallayout>select $OBJECT from
  item-identifier($OBJECT, $LOC),
  not(topic($OBJECT))?
</literallayout>
</example>

<para>
This query will, if run against a topic map that was loaded from an
XTM file, find all objects in the topic map other than topics which
had <symbol>id</symbol> attributes. It works by first finding all
objects which have item identifiers (and the item identifiers), then
remove the rows where the object is a topic.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-subject-identifier">
<refnamediv>
<refname>subject-identifier</refname>
<refpurpose>
Used to query the subject identifiers of a topic. (A subject
identifier is the URI of a subject identifier.)
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>topic</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The topic having the subject identifier.</entry>
</row>
<row>
<entry>locator</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The subject identifier of the topic.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>locator</symbol> is a subject
identifier for the <symbol>topic</symbol>. This is useful for finding
the subject identifiers of a particular topic, for looking up the
topic that has a particular subject identifier, or for listing all
subject identifiers in the topic map.
</para>

<example>
<title>Find all topics which have more than one subject identifier</title>
<literallayout>select $TOPIC from
  subject-identifier($TOPIC, $LOC1),
  subject-identifier($TOPIC, $LOC2),
  $LOC1 /= $LOC2?
</literallayout>
</example>

<para>
The query will first find all subject identifiers in the topic map and
the topics that have them, then for each topic find other subject
identifiers belonging to it (again), and finally remove the rows where
the two subject identifiers are the same.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-subject-locator">
<refnamediv>
<refname>subject-locator</refname>
<refpurpose>
Used to query the subject locator of a topic. (A subject locator is
the URI of the information resource that the topic represents.)
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>topic</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The topic having the subject locator.</entry>
</row>
<row>
<entry>locator</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The subject locator of the topic.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>locator</symbol> is a subject
locator for the <symbol>topic</symbol>. This is useful for finding the
subject locator of a particular topic, for looking up the topic that
has a particular subject locator, or for listing all subject locators
in the topic map.
</para>

<example>
<title>Find all topics which represent an occurrence</title>
<literallayout>select $TOPIC from
  occurrence($OTHERTOPIC, $OCC),
  resource($OCC, $LOC),
  subject-locator($TOPIC, $LOC)?
</literallayout>
</example>

<para>
This query will find all topics which represent information resources
that are occurrences of some topic in the topic map. It starts by
finding all occurrences, then removes all occurrences which don't have
a URI and at the same time notes the URI, and finally finds all topics
which have this URI as their subject locator.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-topic">
<refnamediv>
<refname>topic</refname>
<refpurpose>
Used to verify that an object is a topic or to find all topics in the
topic map.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>topic</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The object that is a topic.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>topic</symbol> is a topic. Can
be used to find all topics or to verify that some object is a topic.
</para>

<example>
<title>Count the topics in the topic map</title>
<literallayout>select count($TOPIC) from
  topic($TOPIC)?
</literallayout>
</example>

<para>
This query will find all topics in the topic map, then count them.
</para>

<example>
<title>Find all topics which have no name</title>
<literallayout>select $TOPIC from
  topic($TOPIC),
  not(topic-name($TOPIC, $NAME))?
</literallayout>
</example>

<para>
This query will find all topics in the topic map, then remove the ones
that have at least one name.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-topic-name">
<refnamediv>
<refname>topic-name</refname>
<refpurpose>
Queries the topic-name relationship.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>topic</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The topic that has the name.</entry>
</row>
<row>
<entry>name</entry>
<entry>topic name</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The name of the topic.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>topic</symbol> has the
<symbol>name</symbol> as a topic name. Note that <symbol>name</symbol>
is <emphasis>not</emphasis> a string, but an object. To find the
string value use the <xref linkend="p-value"/> predicate on the name
object. (Example below.) 
</para>

<para>
The predicate can be used to find all names of a topic, the topic that
has a particular name, or to find all names in the topic map.
</para>

<example>
<title>Find all topics named "Tosca"</title>
<literallayout>select $TOPIC from
  topic-name($TOPIC, $NAME), value($NAME, "Tosca")?
</literallayout>
</example>

<para>
This query will find all topic names in the topic map, then remove the
ones whose string value is not <literal>"Tosca"</literal>. Note that
this will only find names that match exactly. For inexact matching,
use <xref linkend="p-value-like"/>.
</para>

<example>
<title>Find all topics which have no name</title>
<literallayout>select $TOPIC from
  topic($TOPIC),
  not(topic-name($TOPIC, $NAME))?
</literallayout>
</example>

<para>
This query will find all topics in the topic map, then remove the ones
that have at least one name.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-topicmap">
<refnamediv>
<refname>topicmap</refname>
<refpurpose>
Finds the topic map.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>topicmap</entry>
<entry>topic map</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The topic map.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>topicmap</symbol> is the topic
map itself. This is useful for finding the topic map.
</para>

<example>
<title>Find the name of the topic map</title>
<literallayout>select $VALUE from
  topicmap($TM),
  reifies($TMTOPIC, $TM),
  topic-name($TMTOPIC, $NAME),
  value($NAME, $VALUE)?
</literallayout>
</example>

<para>
This query will first find the topic map, then the topic that reifies
it (if any), then all names of that topic, then their string values.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-type">
<refnamediv>
<refname>type</refname>
<refpurpose>
Queries the type of topic map objects (but not topics).
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>object</entry>
<entry>association, topic name, occurrence, association role</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The object having the type.</entry>
</row>
<row>
<entry>type</entry>
<entry>topic</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The type of the object.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>object</symbol> has the
<symbol>type</symbol> as its type. This can be used to find the type
of an object, all objects of a specific type, or all types. This
predicate does not take the superclass-subclass associations into
account. Also note that for topics the <xref linkend="p-instance-of"/>
and <xref linkend="p-direct-instance-of"/> predicates must be used.
</para>

<example>
<title>Find all association types</title>
<literallayout>select $TYPE from
  association($ASSOC),
  type($ASSOC, $TYPE)?
</literallayout>
</example>

<para>
This query will first find all associations, then the type of each
association, and finally produce just a list of the types.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-value">
<refnamediv>
<refname>value</refname>
<refpurpose>
Finds the string value of an object.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>object</entry>
<entry>topic name, variant, occurrence</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The object having the string value.</entry>
</row>
<row>
<entry>value</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The string value of the object.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>object</symbol> has the
<symbol>value</symbol> as its string value. Variant names and
occurrences which have URIs have no string value, and so will not be
matched by this predicate. The predicate can be used to find the
string value of an object, all objects with a specific value, or all
string values.
</para>

<example>
<title>Find all topics named "Tosca"</title>
<literallayout>select $TOPIC from
  topic-name($TOPIC, $NAME), value($NAME, "Tosca")?
</literallayout>
</example>

<para>
This query will find all topic names in the topic map, then remove the
ones whose string value is not <literal>"Tosca"</literal>. Note that
this will only find names that match exactly. For inexact matching,
use <xref linkend="p-value-like"/>.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-datatype">
<refnamediv>
<refname>datatype</refname>
<refpurpose>
Finds the datatype of an occurrence or variant name.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>object</entry>
<entry>variant, occurrence</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The object having the datatype.</entry>
</row>
<row>
<entry>datatype</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The URI of the object's datatype, as a string.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>object</symbol> has the
<symbol>datatype</symbol> as its datatype URI. The predicate can be
used to find the datatype of an object, all objects with a specific
datatype, or all object/datatype combinations.
</para>

<example>
<title>Find all occurrences with integer values</title>
<literallayout>select $OCC from
  occurrence($TOPIC, $OCC),
  datatype($OCC, "http://www.w3.org/2001/XMLSchema#integer")?
</literallayout>
</example>

<para>
This query will find all occurrences in the topic map, then remove the
ones whose datatype is not the XML Schema integer datatype.
</para>
</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-value-like">
<refnamediv>
<refname>value-like</refname>
<refpurpose>
Performs a full-text search.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>object</entry>
<entry>topic name, variant, occurrence</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The object having the string value matched by the full-text
search.</entry>
</row>
<row>
<entry>query</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The full-text query string. tolog does not define the syntax to
be used here; the interpretation depends on the full-text search
engine used by the backend, and different backends may well use
different search engines.</entry>
</row>
<row>
<entry>score</entry>
<entry>float</entry>
<entry>no</entry>
<entry>no</entry>
<entry>The score/relevancy of the matched object. The value is a float 
greater than 0.0 and less than 1.0.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>object</symbol> has a string
value which matches the <symbol>query</symbol>. This can be used to
find topic names, variants, and occurrences matching a particular
string. Note that the object found is <emphasis>not</emphasis> a
topic, but a topic name, variant, or occurrence. The other predicates
must be used to connect this to a topic.
</para>

<example>
<title>Find all topics matching "tosca"</title>
<literallayout>select $TOPIC from
  { topic-name($TOPIC, $NAME), value-like($NAME, "tosca") |
    occurrence($TOPIC, $OCC),  value-like($OCC,  "tosca") |
    topic-name($TOPIC, $TN), variant($TN, $V), value-like($V, "tosca")
    }?
</literallayout>
</example>

<para>
This query will find all topics in the topic map matching the
full-text query, whether the full-text query matches a topic name,
variant, or occurrence.
</para>

<example>
<title>Find default names matching "tosca"</title>
<literallayout>select $NAME, $SCORE from
  topic-name($TOPIC, $NAME), not(scope($NAME, $SCOPE)),
  value-like($NAME, "tosca", $SCORE), $SCORE >= 0.50 ?
</literallayout>
</example>

<para>
This query makes use of the optional third argument to the value-like 
predicate. The query finds all unconstrained topic names containing the 
pattern "tosca", and where the score value is greater than or equal to 
0.50. The score value is also included in the projection.
</para>

</refsect1>
</refentry>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-variant">
<refnamediv>
<refname>variant</refname>
<refpurpose>
Queries the topic name-variant relationship.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>topicname</entry>
<entry>topic name</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The topic name of which the variant is a variant.</entry>
</row>
<row>
<entry>variant</entry>
<entry>variant</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The variant of the topic name.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when the <symbol>variant</symbol> is a variant
of the <symbol>topicname</symbol>. Can be used to find all variants of
a topic name, the topic name of a variant, or all variants. 
</para>

<para>
Note that although XTM allows variants to nest within each other
<ulink url="http://www.isotopicmaps.org/sam/sam-model/">TMDM</ulink>
collapses this structure, and so that structure is not available to be
queried in tolog.
</para>

<example>
<title>Find all topics which have a sort name</title>
<literallayout>select $TOPIC from
  topic-name($TOPIC, $NAME),
  variant($NAME, $VARIANT),
  scope($VARIANT, i"http://www.topicmaps.org/xtm/1.0/core.xtm#sort")?
</literallayout>
</example>

<para>
This query will find all topic names in the topic map together with
their topics, then all variants of the topic names, and finally
removes the rows where the variant is not in the scope of the sort PSI
defined by XTM 1.0.
</para>
</refsect1>
</refentry>
</section>

<!-- ===== EXTERNAL FULLTEXT ================================================-->
<section>
<title>External fulltext predicates</title>

<para>
It is possible to extend tolog with external fulltext predicates by
implementing the <interfacename>SearcherIF</interfacename> and
<interfacename>SearchResultIF</interfacename> interfaces from the
<symbol>net.ontopia.topicmaps.query.spi</symbol> package (see the API
documentation for more information). If the class
<symbol>com.foo.MySearcher</symbol> implements the
<interfacename>SearcherIF</interfacename> interface, that class can be
used in tolog as follows:
</para>

<literallayout>import "urn:x-java:com.foo.MySearcher" as fulltext
select $A, $RELEVANCE from
  fulltext:search($A, "CMS", $RELEVANCE)
order by $RELEVANCE?</literallayout>

<para>
The class name in the import URI is enough for Ontopia to instantiate
the class and use it. The actual predicate name
(<symbol>fulltext:search</symbol> in the example above) does not need
to be significant. The name is passed into the
<interfacename>SearcherIF</interfacename> class, but it is up to the
<interfacename>SearcherIF</interfacename> class to attach significance
to the predicate name. (One alternative is to always use a specific
name, such as "search". Another is to use the name to select which
full-text index to search.)
</para>

<para>
The parameters to external fulltext predicates are:
</para>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>result</entry>
<entry>unspecified</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>This is the value found by the search. The type depends on the
searcher implementation. More information about this below.</entry>
</row>
<row>
<entry>query</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>This is the query passed to the external full-text
implementation.</entry>
</row>
<row>
<entry>relevance</entry>
<entry>float</entry>
<entry>no</entry>
<entry>no</entry>
<entry>This is a floating-point number between 0 and 1 indicating the
relevance of this item in the search result to the search criteria. 1
indicates the highest relevance, 0 the lowest.</entry>
</row>
</tbody>
</tgroup>
</informaltable>

<para>
The <interfacename>SearcherIF</interfacename> implementation can
produce values of different types, as indicated by the
<methodname>getValueType</methodname> method. The table below explains
the different possible values.
</para>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Value type</entry>
<entry>Result type</entry>
<entry>Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry><symbol>SUBJECT_LOCATOR</symbol></entry>
<entry>topic</entry>
<entry>The searcher must return a string, and the predicate will
return the topic with that subject locator.</entry>
</row>
<row>
<entry><symbol>SUBJECT_IDENTIFIER</symbol></entry>
<entry>topic</entry>
<entry>The searcher must return a string, and the predicate will
return the topic with that subject identifier.</entry>
</row>
<row>
<entry><symbol>ITEM_IDENTIFIER</symbol></entry>
<entry>topic map object</entry>
<entry>The searcher must return a string, and the predicate will
return the topic map object with that item identifier (a.k.a. source
locator).</entry>
</row>
<row>
<entry><symbol>OBJECT_ID</symbol></entry>
<entry>topic map object</entry>
<entry>The searcher must return a string, and the predicate will
return the topic map object with that object ID.</entry>
</row>
<row>
<entry><symbol>STRING_VALUE</symbol></entry>
<entry>string</entry>
<entry>The predicate will return the result of calling the
<methodname>toString</methodname> on the object returned by the
searcher. There is no defined Topic Maps interpretation of the
string.</entry>
</row>
<row>
<entry><symbol>OBJECT_VALUE</symbol></entry>
<entry>any</entry>
<entry>The predicate will return the the object returned by the
searcher. There is no defined Topic Maps interpretation of the
object.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>

<!-- ===== STRING ==========================================================-->
<section>
<title>The string module</title>

<para>
The URI of this module is
<symbol>http://psi.ontopia.net/tolog/string/</symbol>. For usage, see
the examples.
</para>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<refentry id="p-str-concat">
<refnamediv>
<refname>concat</refname>
<refpurpose>
Concatenates two strings.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>OUT</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The concatenated string.</entry>
</row>
<row>
<entry>IN1</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The first of the two strings to concatenate.</entry>
</row>
<row>
<entry>IN2</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The second of the two strings to concatenate.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>OUT</parameter> is equal to
<parameter>IN1</parameter> immediately followed by
<parameter>IN2</parameter>. 
</para>

<example>
<title>Concatenate two strings</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
  str:concat($NAME, "Ontopia", " AS")? 
</literallayout>

<para>
This results in a single row with a single column containing the
string <literal>"Ontopia AS"</literal>.
</para>
</example>
</refsect1>
</refentry>

<refentry id="p-str-index-of">
<refnamediv>
<refname>index-of</refname>
<refpurpose>
Finds the first occurrence of a substring within another string.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>OUT</entry>
<entry>number</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The position of the substring.</entry>
</row>
<row>
<entry>IN</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to search in.</entry>
</row>
<row>
<entry>SEARCHFOR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The substring to search for.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>SEARCHFOR</parameter> can be
found inside <parameter>IN</parameter> starting at position
<parameter>OUT</parameter>, and there are no occurrences of
<parameter>SEARCHFOR</parameter> at a lower position inside
<parameter>IN</parameter>. Position counts start at zero.

This means that if the substring cannot be found at all the predicate
does not match. Multiple occurrences of the substring later in the
string are ignored.
</para>

<example>
<title>Find the first occurrence of a word in a string.</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
  str:index-of($POS, "The first occurrence of 'the' in the sentence.", "the")? 
</literallayout>

<para>
This results is a single row with a single column containing the position of the
left-most occurrence of 'the' (all lowercase)
in the sentence, i.e. <literal>25</literal>.
</para>
</example>
</refsect1>
</refentry>

<refentry id="p-str-last-index-of">
<refnamediv>
<refname>last-index-of</refname>
<refpurpose>
Finds the last occurrence of a substring within another string.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>OUT</entry>
<entry>number</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The position of the substring.</entry>
</row>
<row>
<entry>IN</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to search in.</entry>
</row>
<row>
<entry>SEARCHFOR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The substring to search for.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>SEARCHFOR</parameter> can be
found inside <parameter>IN</parameter> starting at position
<parameter>OUT</parameter>, and there are no occurrences of
<parameter>SEARCHFOR</parameter> at a higher position inside
<parameter>IN</parameter>. Position counts start at zero.

This means that if the substring cannot be found at all the predicate
does not match. Multiple occurrences of the substring earlier in the
string are ignored.
</para>

<example>
<title>Find all PSI namespaces in a topic map</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
select $PREFIX from
  subject-identifier($TOPIC, $SI),
  str:last-index-of($IX, $SI, "/"),
  str:substring($PREFIX, $SI, 0, $IX)
order by $PREFIX?</literallayout>

<para>
In the following topic map:
</para>

<literallayout>[subtype-of : hierarchical-relation-type = "Subtype of"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass-subclass"]
[supertype = "Supertype"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass"]
[subtype = "Subtype"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#subclass"]
[descr = "Description"
    @"http://psi.ontopia.net/occurrence/description"]
</literallayout>

<para>
The result of this query would be two rows, containing
<literal>"http://www.topicmaps.org/xtm/1.0/"</literal> and
<literal>"http://psi.ontopia.net/occurrence/"</literal>.
</para>
</example>
</refsect1>
</refentry>

<refentry id="p-str-starts-with">
<refnamediv>
<refname>starts-with</refname>
<refpurpose>
Tests whether a substring appears at the beginning of another string.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>STR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to test.</entry>
</row>
<row>
<entry>PREFIX</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The substring that must appear at the beginning of
<parameter>STR</parameter>.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>PREFIX</parameter> appears
inside <parameter>STR</parameter> starting at position 0.
</para>

<example>
<title>Find all PSIs defined by Ontopia</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
select $SI from
  subject-identifier($TOPIC, $SI),
  str:starts-with($SI, "http://psi.ontopia.net/")?</literallayout>

<para>
In the following topic map:
</para>

<literallayout>[subtype-of : hierarchical-relation-type = "Subtype of"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass-subclass"]
[supertype = "Supertype"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass"]
[subtype = "Subtype"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#subclass"]
[descr = "Description"
    @"http://psi.ontopia.net/occurrence/description"]
</literallayout>

<para>
The result of this query would be one row, containing
<literal>"http://psi.ontopia.net/occurrence/description"</literal>.
</para>
</example>
</refsect1>
</refentry>

<refentry id="p-str-ends-with">
<refnamediv>
<refname>ends-with</refname>
<refpurpose>
Tests whether a substring appears at the end of another string.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>STR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to test.</entry>
</row>
<row>
<entry>SUFFIX</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The substring that must appear at the end of
<parameter>STR</parameter>.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>SUFFIX</parameter> appears
as the last part of <parameter>STR</parameter>. In other words, if
<parameter>STR</parameter> is the concatenation of some other string
and <parameter>SUFFIX</parameter> the predicate is true.
</para>

<example>
<title>Find all class PSIs</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
select $SI from
  subject-identifier($TOPIC, $SI),
  str:ends-with($SI, "class")?</literallayout>

<para>
In the following topic map:
</para>

<literallayout>[subtype-of : hierarchical-relation-type = "Subtype of"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass-subclass"]
[supertype = "Supertype"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass"]
[subtype = "Subtype"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#subclass"]
[descr = "Description"
    @"http://psi.ontopia.net/occurrence/description"]
</literallayout>

<para>
The result of this query would be three rows, containing
<literal>"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass-subclass"</literal>,
<literal>"http://www.topicmaps.org/xtm/1.0/core.xtm#subclass"</literal>, and
<literal>"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass"</literal>.
</para>
</example>
</refsect1>
</refentry>

<refentry id="p-str-contains">
<refnamediv>
<refname>contains</refname>
<refpurpose>
Tests whether a substring appears in another string.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>STR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to test.</entry>
</row>
<row>
<entry>SUBSTRING</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The substring that must appear inside
<parameter>STR</parameter>.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>SUBSTRING</parameter> appears at
some position inside <parameter>STR</parameter>.
</para>

<example>
<title>Find all PSIs defined by Ontopia</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
select $SI from
  subject-identifier($TOPIC, $SI),
  str:contains($SI, ".ontopia.net/")?</literallayout>

<para>
In the following topic map:
</para>

<literallayout>[subtype-of : hierarchical-relation-type = "Subtype of"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass-subclass"]
[supertype = "Supertype"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#superclass"]
[subtype = "Subtype"
  @"http://www.topicmaps.org/xtm/1.0/core.xtm#subclass"]
[descr = "Description"
    @"http://psi.ontopia.net/occurrence/description"]
</literallayout>

<para>
The result of this query would be one row, containing
<literal>"http://psi.ontopia.net/occurrence/description"</literal>.
</para>
</example>
</refsect1>
</refentry>

<refentry id="p-str-length">
<refnamediv>
<refname>length</refname>
<refpurpose>
Finds the length of a string.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>STR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to test.</entry>
</row>
<row>
<entry>LENGTH</entry>
<entry>number</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The number of characters in
<parameter>STR</parameter>.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>STRING</parameter> contains
exactly <parameter>LEN</parameter> characters.
</para>

<example>
<title>Find the topics with the longest names</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
select $TOPIC from
  topic-name($TOPIC, $TN),
  value($TN, $NAME),
  str:length($NAME, $LEN),
  not(topic-name($TOPIC2, $TN2),
      value($TN2, $NAME2),
      str:length($NAME2, $LEN2),
      $LEN &lt; $LEN2)?</literallayout>

<para>
This query will find the topic with the longest name, or almost. What
it in fact will do is to find all topics for which there is no topic
with a longer name. This means that if, say, three topics all have
names 26 characters long, and no topics have longer names, then all
those three topics will be found.
</para>      
</example>
</refsect1>
</refentry>

<refentry id="p-str-translate">
<refnamediv>
<refname>translate</refname>
<refpurpose>
Replace and/or delete characters in one string. Often used to remove
whitespace or do case normalization.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>OUT</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The resulting string.</entry>
</row>
<row>
<entry>STR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to operate on.</entry>
</row>
<row>
<entry>FROM</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The list of characters to translate from.</entry>
</row>
<row>
<entry>TO</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The list of characters to translate to.</entry>
</row>
<row>
<entry>DELETE</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The list of characters to remove.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate builds a translation table where the first character in
<parameter>FROM</parameter> maps to the first character in
<parameter>TO</parameter> (and so on). This is the basic function
performed by the predicate.
</para>

<para>
The predicate is really a mix of the XPath <symbol>translate</symbol>
function and the Python <symbol>translate</symbol> function, turned
into a predicate. If the <parameter>DELETE</parameter> parameter is
provided it behaves like the Python function, and if not it behaves
like the XPath function.
</para>

<para>
That is, if the <parameter>DELETE</parameter> is not present, then the
predicate translates characters as specified by the translation table,
but any characters for which no mapping has been defined will be
deleted. Characters in the <parameter>FROM</parameter> string for
which there are no corresponding characters in the
<parameter>TO</parameter> string will map to themselves (that is, if
<parameter>FROM</parameter> is longer than <parameter>TO</parameter>).
Conversely, if <parameter>TO</parameter> is longer than
<parameter>FROM</parameter> any excess characters in
<parameter>TO</parameter> will be ignored.
</para>

<example>
<title>Lowercasing</title>
<literallayout>
import "http://psi.ontopia.net/tolog/string/" as str
select $OUT from
  str:translate($OUT,
    "Addis Abeba (12)",
    "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz ",
    "abcdefghijklmnopqrstuvxyzabcdefghijklmnopqrstuvxyz ")?
</literallayout>
</example>

<para>
The example above produces "addis abeba " as the output. If we remove
the space at the end of the <parameter>FROM</parameter> string the
result is "addisabeba".
</para>

<para>
If the <parameter>DELETE</parameter> <emphasis>is</emphasis> present,
then the predicate translates characters as specified by the
translation table and any characters for which no mapping has been
defined will be mapped to themselves. Any characters in the
<parameter>DELETE</parameter> string will be deleted, of course. If
<parameter>FROM</parameter> and <parameter>TO</parameter> are of
different lengths the effect is the same as specified above when
<parameter>DELETE</parameter> is not present.
</para>

<example>
<title>Lowercasing</title>
<literallayout>
import "http://psi.ontopia.net/tolog/string/" as str
select $OUT from
  str:translate($OUT,
    "Addis Abeba (12)",
    "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz",
    "abcdefghijklmnopqrstuvxyzabcdefghijklmnopqrstuvxyz",
    "()")?
</literallayout>
</example>

<para>
The example above produces "addis abeba 12" as the output.
</para>
</refsect1>
</refentry>

<refentry id="p-str-substring">
<refnamediv>
<refname>substring</refname>
<refpurpose>
Extract part of a string.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>OUT</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The resulting string.</entry>
</row>
<row>
<entry>STR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to operate on.</entry>
</row>
<row>
<entry>FROM</entry>
<entry>number</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The position of the start of the substring.</entry>
</row>
<row>
<entry>TO</entry>
<entry>number</entry>
<entry>yes</entry>
<entry>no</entry>
<entry>The position of the end of the substring.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>OUT</parameter> is equal to the
substring of <parameter>STR</parameter> starting at position
<parameter>FROM</parameter> and ending at position
<parameter>TO</parameter> (non-inclusive). If
<parameter>TO</parameter> is not given, the substring extends to the
end of the string. All position counts are zero-based.
</para>

<example>
<title>Find all PSI namespaces in a topic map</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
select $PREFIX from
  subject-identifier($TOPIC, $SI),
  str:last-index-of($IX, $SI, "/"),
  str:substring($PREFIX, $SI, 0, $IX)
order by $PREFIX?</literallayout>

<para>
This query would produce all PSI namespaces used in a given topic map.
</para>
</example>
</refsect1>
</refentry>

<refentry id="p-str-substring-after">
<refnamediv>
<refname>substring-after</refname>
<refpurpose>
Extract part of a string after the first occurrence of a substring.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>OUT</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The resulting string.</entry>
</row>
<row>
<entry>STR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to operate on.</entry>
</row>
<row>
<entry>SUB</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The substring to search for.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>OUT</parameter> is equal to the
substring of <parameter>STR</parameter> after the first occurrence
of <parameter>SUB</parameter> within <parameter>STR</parameter>. If
there are no occurrences of <parameter>SUB</parameter> the predicate
is false.
</para>

<example>
<title>Get month and day</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
select $DATE from
  str:substring-after($DATE, "2007-03-12", "-")?</literallayout>

<para>
This query would produce <literal>03-12</literal>.
</para>
</example>
</refsect1>
</refentry>

<refentry id="p-str-substring-before">
<refnamediv>
<refname>substring-before</refname>
<refpurpose>
Extract part of a string before the first occurrence of a substring.
</refpurpose>
</refnamediv>

<refsect1>
<title>Parameters</title>

<informaltable>
<tgroup cols="3">
<thead>
<row>
<entry>Name</entry>
<entry>Type</entry>
<entry>Must be bound</entry>
<entry>Required</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry>OUT</entry>
<entry>string</entry>
<entry>no</entry>
<entry>yes</entry>
<entry>The resulting string.</entry>
</row>
<row>
<entry>STR</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The string to operate on.</entry>
</row>
<row>
<entry>SUB</entry>
<entry>string</entry>
<entry>yes</entry>
<entry>yes</entry>
<entry>The substring to search for.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</refsect1>

<refsect1>
<title>Description</title>

<para>
The predicate is true when <parameter>OUT</parameter> is equal to the
substring of <parameter>STR</parameter> before the first occurrence
of <parameter>SUB</parameter> within <parameter>STR</parameter>. If
there are no occurrences of <parameter>SUB</parameter> the predicate
is false.
</para>

<example>
<title>Get month and day</title>
<literallayout>import "http://psi.ontopia.net/tolog/string/" as str
select $DATE from
  str:substring-before($DATE, "2007-03-12", "-")?</literallayout>

<para>
This query would produce <literal>2007</literal>.
</para>
</example>
</refsect1>
</refentry>
</section>
</article>
